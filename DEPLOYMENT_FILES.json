{
  "vercel.json": {
    "buildCommand": "prisma generate && next build",
    "env": {
      "PRISMA_GENERATE_SKIP_AUTOINSTALL": "true"
    }
  },
  "DEPLOYMENT_GUIDE.md": "# Digital Menu SaaS - Production Deployment\n\n## \ud83d\ude80 Vercel + Neon + Stripe Setup\n\n### 1. Database Setup (Neon)\n1. Create account at neon.tech\n2. Create new database project\n3. Copy connection string (looks like: postgresql://username:password@host/dbname)\n\n### 2. Vercel Deployment\n1. Connect GitHub repo to Vercel\n2. Set environment variables in Vercel dashboard:\n   - DATABASE_URL (from Neon)\n   - NEXTAUTH_SECRET (generate: openssl rand -base64 32)\n   - NEXTAUTH_URL (your Vercel domain)\n   - OPENAI_API_KEY (from OpenAI)\n   - Stripe keys (from Stripe dashboard)\n\n### 3. Stripe Setup\n1. Create Stripe account\n2. Create products and prices:\n   - Basic: $49/month\n   - Premium: $99/month  \n   - Enterprise: $199/month\n3. Set up webhook endpoint: https://your-domain.vercel.app/api/stripe/webhook\n\n### 4. Domain & SSL\n1. Add custom domain in Vercel\n2. SSL automatically handled by Vercel\n\n### 5. Post-Deployment\n1. Run database migrations via Vercel functions\n2. Seed demo data\n3. Test all features\n4. Set up monitoring\n\n## \ud83d\udcca Production Checklist\n- [ ] Database connected and seeded\n- [ ] Authentication working\n- [ ] AI assistant responding\n- [ ] Stripe billing functional\n- [ ] Admin dashboards accessible\n- [ ] Widget embeddable\n- [ ] Custom domain configured\n- [ ] SSL certificate active\n- [ ] Error monitoring set up\n\n## \ud83d\udcb0 Ready for Revenue!\nYour SaaS is production-ready with:\n- Multi-tenant architecture\n- Automated billing\n- AI-powered customer experience\n- Complete admin system\n- Client customization framework\n",
  "SCALING_OPTIMIZATIONS.md": "# Digital Menu SaaS - Production Scaling\n\n## \u26a1 Performance Optimizations\n\n### 1. Streaming AI Responses\n```typescript\n// app/api/assistant/route.ts - Add streaming\nconst stream = await openai.chat.completions.create({\n  model: \"gpt-4o-mini\",\n  messages: messages,\n  stream: true\n})\n\nreturn new Response(stream)\n```\n\n### 2. Menu Data Caching\n```typescript\n// lib/cache.ts - Redis caching\nimport Redis from 'ioredis'\n\nconst redis = new Redis(process.env.REDIS_URL)\n\nexport async function getCachedMenu(tenantSlug: string) {\n  const cached = await redis.get(`menu:${tenantSlug}`)\n  if (cached) return JSON.parse(cached)\n  \n  const menu = await fetchMenuFromDB(tenantSlug)\n  await redis.setex(`menu:${tenantSlug}`, 300, JSON.stringify(menu)) // 5min cache\n  return menu\n}\n```\n\n### 3. Usage Monitoring\n```typescript\n// lib/analytics.ts - Track usage per tenant\nexport async function trackAIUsage(tenantId: string) {\n  await prisma.usageMetric.create({\n    data: {\n      tenantId,\n      type: 'AI_REQUEST',\n      timestamp: new Date()\n    }\n  })\n  \n  // Check if over plan limits\n  const monthlyUsage = await getMonthlyAIUsage(tenantId)\n  if (monthlyUsage > tenantPlan.aiLimit) {\n    // Throttle or upsell\n  }\n}\n```\n\n### 4. Tenant Sharding\n```typescript\n// lib/tenant-router.ts - Route tenants to different instances\nexport function getTenantShard(tenantSlug: string) {\n  const hash = createHash('md5').update(tenantSlug).digest('hex')\n  const shardId = parseInt(hash.substring(0, 8), 16) % TOTAL_SHARDS\n  return `shard-${shardId}`\n}\n```\n\n## \ud83d\udcca Monitoring Dashboard\n- Track AI usage per tenant\n- Monitor response times\n- Database query performance\n- Revenue metrics per tenant\n- Customer satisfaction scores\n"
}